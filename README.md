# Sparse table, segment and Fenwick tree

Здесь реализованы следующие алгоритмы:
- [Sparse table](sparse_table.h)
- [Segment tree](segment_tree.h)
- [Fenwick tree](fenwick_tree.h)

С помощью данных алгоритмов(и их модификаций) решены следующие задачи

## [1 Problem](1_problem.cpp)
Данная задача (в оригинальной версии условия) предлагалась во втором этапе отбора в ШАД в 2019 году в качестве второй по сложности.
Программа должна обрабатывать следующие события:
- RUN user page — сохранить факт того, что исполнитель под номером user написал page секунд. Если ранее такой исполнитель не встречался, необходимо его добавить. Гарантируется, что в рамках одного исполнителя записанные секунды в соответствующих ему событиях возрастают.
- CHEER user — сообщить исполнителю user, какая доля существующих исполнителей (не считая его самого) записала меньшее число секунд, чем он. Если этот исполнитель на данный момент единственный, доля считается равной 1. Если для данного исполнителя пока не было ни одного события RUN, доля считается равной 0, а сам исполнитель не учитывается при вычислении долей для других до тех пор, пока для него не случится событие RUN.

### Формат ввода

В первой строке вводится количество запросов Q — натуральное число, не превосходящее ![equation](https://latex.codecogs.com/svg.image?&space;10^5). В следующих Q строках в соответствии с описанным выше форматом вводятся запросы.
Гарантируется, что все вводимые числа целые и положительные, при этом номера исполнителей не превосходят ![equation](https://latex.codecogs.com/svg.image?&space;10^5), а суммарное время альбома не превосходит 42195 секунд.

### Формат вывода

Для каждого запроса CHEER user выведите единственное вещественное число от 0 до 1 — ответ на запрос.
Формат вывода этого числа — 6 значащих цифр.

### Пример
#### Ввод
```
12
CHEER 5
RUN 1 10
CHEER 1
RUN 2 5
RUN 3 7
CHEER 2
CHEER 3
RUN 3 10
CHEER 3
RUN 3 11
CHEER 3
CHEER 1
```
#### Вывод
```
0
1
0
0.5
0.5
1
0.5
```

### Решение
Фигачим ДО

## 2_problem
Нужно уметь находить сумму вида ![equation](https://latex.codecogs.com/svg.image?&space;a_l-a_{l&plus;1}&plus;\cdots&plus;(-1)^{r-l}a_r)

### Формат ввода

В первой строке входного файла содержится натуральное число n — длина массива с почасовыми реакциями. Во второй строке записаны начальные значения элементов
В третьей строке находится натуральное число m — количество запросов исполнителя. В последующих m  строках записаны операции:
- операция изменения значения задается тремя числами 0 i j. Формально, ![equation](https://latex.codecogs.com/svg.image?a_i=j)
- операция запроса поддержки задается тремя числами 1 l r - найти указанную сумму
### Формат вывода

Для каждой операции второго типа выведите на отдельной строке соответствующую знакочередующуюся сумму.

### Пример
#### Ввод
```
3
1 2 3
5
1 1 2
1 1 3
1 2 3
0 2 1
1 1 3
```
#### Вывод
```
-1
2
-1
3
```
### Решение
Фигачим ДО на четных и нечетных индексах, дальше понятно, что делать.
## [3 Problem](3_problem.cpp)
Нужно уметь отвечать всего лишь на два запроса:
- set(i, x) — присвоить i-му месту рейтинг x.
- get(i, x) — найти ближайшую справа (в массиве рейтинга мест) локацию от i-й (включая ее саму) с числом очков не меньшим, чем x. Надо вывести ее индекс.
### Формат ввода
На первой строке длина массива n и количество запросов m.
На второй строке n целых чисел. Следующие m строк содержат запросы.\
Запрос типа set: «0 i x».\
Запрос типа get: «1 i x».\
Все числа в вводе не превосходят двухсот тысяч.
### Формат вывода
На каждой запрос типа «get» на отдельной строке выведите нужный индекс. Если такого k не существует, выведите −1.
### Пример
#### Ввод
```
4 5
1 2 3 4
1 1 1
1 1 3
1 1 5
0 2 3
1 1 3
```
#### Вывод
```
1
3
-1
2
```
### Решение
Построим ДО на максимуме на данном массиве. При запросе найдем O(log n) вершин в ДО, полностью покрывающих наш отрезок. Начнем с самой правой вершины, если максиум в ней >= x, то двоичным спуском находим ответ, иначе берем следующую вершину и делаем аналогично и т.д.
## [4 Problem](4_problem.cpp)
Нужно отвечать на запросы вида
- +x — добавить в мультимножество число. 
- ? x — посчитать сумму чисел не больших x.
### Формат ввода
В первой строке содержится число запросов q
Далее каждая строка содержит один запрос.
Все числа x целые.
### Формат вывода
Ответы на все запросы вида ? x.
### Пример
#### Ввод
```
8
+ 1
+ 2
? 3
? 2
? 1
? 0
+ 1
? 1
```
#### Вывод
```
3
3
1
0
2
```
### Решение
Решим задачу в оффлайне. Будем хранить дерево Фенвика текущих живых элементов. Изначально все они метрвы(то есть 0). Отсортируем все запросы по x. На запросе находим x в отсортированном массиве, и в случае update оживляем данный элемент, а в случае get просто находим сумму на префиксе до найденного индекса(в этот момент на отрезку ненулевыми будут только элементы ≤ x).
## [5 Problem](5_problem.cpp)
Марк любит наблюдать за звездами над Пантеллерией. Но следить за ними и над Риадом, и над Мединой ему крайне тяжело. Поэтому он наблюдает только за частью пространства, ограниченной кубом размером n x n x n . Этот куб поделен на маленькие кубики размером 1 x 1 x 1. Во время его наблюдений могут происходить следующие события:
1. В каком-то кубике появляются или исчезают несколько звезд.
2. К нему может заглянуть его друг Рома и поинтересоваться, сколько видно звезд в части пространства, состоящей из нескольких кубиков.
### Формат ввода
Первая строка входного файла содержит натуральное число n. Координаты кубиков — целые числа от 0 до n - 1
Далее следуют записи о происходивших событиях по одной в строке. В начале строки записано число m
Если m равно:
1. то за ним следуют 4 числа — x, y, z и k — координаты кубика и величина, на которую в нем изменилось количество видимых звезд;
2. то за ним следуют 6 чисел — x1, y1, z1, x2, y2, z2. Рома хочет посчитать кол-во звезд в области x1≤x≤x2, y1≤y≤y2, z1≤z≤z2
3. то это означает, что Марку надоело наблюдать за звездами и отвечать на вопросы Ромы. Эта запись встречается во входном файле только один раз и будет последней записью.
### Формат вывода
Для каждого вопроса Ромы выведите на отдельной строке одно число — искомое количество звезд.
### Пример
#### Ввод
```
2
2 1 1 1 1 1 1
1 0 0 0 1
1 0 1 0 3
2 0 0 0 0 0 0
2 0 0 0 0 1 0
1 0 1 0 -2
2 0 0 0 1 1 1
3
```
#### Вывод
```
0
1
4
2
```
### Решение
Фигачим Фенвика по 3 измерениям, осталось вывести правильную формулу, используя префиксные суммы. 
## [6 Problem](6_problem.cpp)
Даны n точек с весами на плоскости. Каждая задаётся тремя числами ![equation](https://latex.codecogs.com/svg.image?x_i,y_i,w_i)(координаты и вес). Вам нужно обработать m запросов двух типов:
- get rx ry – посчитать сумму весов точек, у которых x≤rx, y≤ry.
- change i z – задать i -й точке новый вес равный z.
### Формат ввода
На первой строке число
n
(
1
≤
n
≤
1
0
0
0
0
0
). На следующих
n
строках тройки целых чисел
x
i
,
y
i
,
w
i
(
0
≤
x
i
,
y
i
,
w
i
<
1
0
9
). Следующая строка содержит количество запросов
m
(
1
≤
m
≤
3
0
0
0
0
0
). На следующих
m
строках описания запросов в формате get rx, ry и change i z. Здесь
1
≤
i
≤
n
, а остальные числа целые от
0
до ![equation](https://latex.codecogs.com/svg.image?10^9-1)
.
### Формат вывода
Для каждого запроса типа “get” выведите одно целое число на отдельной строке — ответ на запрос.
### Пример
#### Ввод
```
3
1 1 10
2 3 100
3 2 1000
4
get 2 3
change 2 200
get 3 3
get 3 2
```
#### Вывод
```
110
1210
1010
```
### Решение
Отсортируем координаты по (x, y). Фигачим двумерное дерево Фенвика. на отсортированном массиве. То есть в каждом из отрезков F(i) - 1, i будет дерево Фенвика. На запросе get rx ry ищем бинпоиском по x индекс в ДФ. Далее на как в обычном дереве Фенвика получаем O(log n) подотрезков, на каждом из которых есть дерево Фенвика, там бинпоиском по y ищем границу по y и добавляем к ответу сумму на префиксе. Итого асимптотика O(log^2 N)
## [7 Problem](7_problem.cpp)
Дан массив длины N. Поступают M запросов найти 2-ю порядковую статистику на отрезке.
### Формат ввода
В первой строке заданы
2
числа: размер последовательности
N
и количество диапазонов
M
.
Следующие
N
целых чисел задают последовательность. Далее вводятся
M
пар чисел - границ диапазонов. Гарантируется, что каждый диапазон содержит как минимум
2
элемента.
### Формат вывода
Для каждого из M диапазонов напечатать элемент последовательности - 2ю порядковую статистику. По одному числу в строке.
### Пример
#### Ввод
```
10 3
1 2 3 4 5 6 7 8 9 10
1 2
1 10
2 7
```
#### Вывод
```
2
2
3
```
### Решение
С помощью SparseTable находим минимум, затем ищем минимум в 2 отрезках, на который делит найденный минимум отрезок из запроса и сравниваем.